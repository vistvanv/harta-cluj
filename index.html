<!doctype html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <title>Străzi – OpenLayers</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@latest/ol.css">
  <style>
    html, body, #map { height: 100%; margin: 0; }

    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      background: rgba(255,255,255,0.92);
      padding: 10px;
      border-radius: 10px;
      box-shadow: 0 1px 8px rgba(0,0,0,0.18);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: 14px;
      min-width: 300px;
      max-width: 340px;
    }

    #controls label {
      display: block;
      margin-bottom: 6px;
      font-weight: 600;
    }

    select {
      width: 100%;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,0.15);
      background: white;
      font-size: 14px;
    }

    #basemapSelect { margin-bottom: 10px; }

    #hint {
      margin-top: 8px;
      font-size: 12px;
      opacity: 0.75;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label for="basemapSelect">Basemap</label>
    <select id="basemapSelect">
      <option value="carto_light" selected>CARTO Positron (light)</option>
      <option value="carto_dark">CARTO Dark Matter</option>
      <option value="osm">OpenStreetMap (color)</option>
    </select>

    <label for="attributeSelect">Color by</label>
    <select id="attributeSelect"></select>

    <div id="hint">Tip: hover peste stradă pentru detalii.</div>
  </div>

  <div id="map"></div>

  <script src="https://cdn.jsdelivr.net/npm/ol@latest/dist/ol.js"></script>
  <script>
    // ---- Config: keep ONLY these attributes in the dropdown ----
    // IMPORTANT: keys must match your GeoJSON property names EXACTLY.
    // I kept Romanian diacritics where you used them earlier (e.g. ZONĂ FISCALĂ).
    const ALLOWED_ATTRIBUTES = [
      'STANDARD CARTIER',
      'DISTANȚA FAȚĂ DE CENTRU',
      'TIP CAROSABIL',
      'GRAD DE DOTARE',
      'CARACTERISTICI GEO',
      'RESTRICTII PUG',
      'GRAD DE POLUARE',
      'ZONĂ FISCALĂ'
    ];

    // Selected attribute
    let selectedAttribute = 'ZONĂ FISCALĂ';

    // Street name fields for tooltip (fallback chain)
    const NAME_FIELDS = ['STRADA', 'DENUMIRE', 'Nume', 'name', 'Name'];

    // A/B/C/D palette for common zoning-like categories
    const gradeColors = {
      'A': '#1a9641',
      'B': '#a6d96a',
      'C': '#fdae61',
      'D': '#d7191c',
      'C/D': '#f46d43'
    };

    // Cache styles for performance
    const styleCache = new Map();
    function styleForColor(color) {
      if (!styleCache.has(color)) {
        styleCache.set(color, new ol.style.Style({
          stroke: new ol.style.Stroke({ color, width: 3 })
        }));
      }
      return styleCache.get(color);
    }

    // Stable color from any value (categorical): hash -> HSL
    function colorFromValue(v) {
      const s = String(v ?? '—');
      let hash = 0;
      for (let i = 0; i < s.length; i++) hash = (hash * 31 + s.charCodeAt(i)) >>> 0;
      const hue = hash % 360;
      return `hsl(${hue} 65% 45%)`;
    }

    function styleFeature(feature) {
      const v = feature.get(selectedAttribute);
      const color = (v in gradeColors) ? gradeColors[v] : colorFromValue(v);
      return styleForColor(color);
    }

    // Vector layer
    const streetsLayer = new ol.layer.Vector({
      source: new ol.source.Vector({
        url: './strazi_impozite.geojson',
        format: new ol.format.GeoJSON()
      }),
      style: styleFeature
    });

    // Basemaps (Option 1 grayscale + OSM color)
    const basemaps = {
      carto_light: new ol.layer.Tile({
        visible: true,
        source: new ol.source.XYZ({
          url: 'https://{a-d}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
          attributions: '© OpenStreetMap contributors © CARTO'
        })
      }),
      carto_dark: new ol.layer.Tile({
        visible: false,
        source: new ol.source.XYZ({
          url: 'https://{a-d}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
          attributions: '© OpenStreetMap contributors © CARTO'
        })
      }),
      osm: new ol.layer.Tile({
        visible: false,
        source: new ol.source.OSM()
      })
    };

    const map = new ol.Map({
      target: 'map',
      layers: [
        basemaps.carto_light,
        basemaps.carto_dark,
        basemaps.osm,
        streetsLayer
      ],
      view: new ol.View({
        center: ol.proj.fromLonLat([23.6, 46.77]),
        zoom: 12
      })
    });

    // ---- Tooltip on hover ----
    const tooltip = document.createElement('div');
    tooltip.style.position = 'absolute';
    tooltip.style.background = 'rgba(255,255,255,0.95)';
    tooltip.style.padding = '6px 8px';
    tooltip.style.borderRadius = '10px';
    tooltip.style.boxShadow = '0 1px 10px rgba(0,0,0,0.2)';
    tooltip.style.fontFamily = 'system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';
    tooltip.style.fontSize = '13px';
    tooltip.style.pointerEvents = 'none';
    tooltip.style.transform = 'translate(10px, 10px)';
    tooltip.style.display = 'none';
    document.body.appendChild(tooltip);

    function getStreetName(feature) {
      for (const k of NAME_FIELDS) {
        const val = feature.get(k);
        if (val !== undefined && val !== null && String(val).trim() !== '') return String(val);
      }
      return '(fără nume)';
    }

    map.on('pointermove', (evt) => {
      const feature = map.forEachFeatureAtPixel(evt.pixel, f => f);
      if (!feature) {
        tooltip.style.display = 'none';
        return;
      }
      const streetName = getStreetName(feature);
      const v = feature.get(selectedAttribute);

      tooltip.innerHTML = `
        <div><b>${streetName}</b></div>
        <div>${selectedAttribute}: <b>${(v ?? '—')}</b></div>
      `;
      tooltip.style.left = `${evt.originalEvent.pageX}px`;
      tooltip.style.top  = `${evt.originalEvent.pageY}px`;
      tooltip.style.display = 'block';
    });

    // ---- Basemap selector wiring ----
    document.getElementById('basemapSelect').addEventListener('change', (e) => {
      const chosen = e.target.value;
      for (const [key, layer] of Object.entries(basemaps)) {
        layer.setVisible(key === chosen);
      }
    });

    // ---- Attribute selector: ONLY allowed list, but skip ones not present in data ----
    const selectEl = document.getElementById('attributeSelect');

    streetsLayer.getSource().on('change', () => {
      if (streetsLayer.getSource().getState() !== 'ready') return;

      // Fit to data once loaded
      const extent = streetsLayer.getSource().getExtent();
      if (extent && extent.every(Number.isFinite)) {
        map.getView().fit(extent, { padding: [30,30,30,30] });
      }

      // Populate dropdown once
      if (selectEl.options.length > 0) return;

      const first = streetsLayer.getSource().getFeatures()[0];
      if (!first) return;

      const props = first.getProperties();
      const available = ALLOWED_ATTRIBUTES.filter(k => Object.prototype.hasOwnProperty.call(props, k));

      // If none match exactly (usually diacritics / naming), fall back to showing the allowed list anyway
      // so you can see what doesn't match and adjust keys.
      const keysToShow = available.length ? available : ALLOWED_ATTRIBUTES;

      for (const k of keysToShow) {
        const opt = document.createElement('option');
        opt.value = k;
        opt.textContent = k;
        selectEl.appendChild(opt);
      }

      // Default selection
      if (!keysToShow.includes(selectedAttribute)) {
        selectedAttribute = keysToShow[0];
      }
      selectEl.value = selectedAttribute;
      streetsLayer.changed();
    });

    selectEl.addEventListener('change', (e) => {
      selectedAttribute = e.target.value;
      streetsLayer.changed();
    });
  </script>
</body>
</html>
