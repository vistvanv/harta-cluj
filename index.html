<!doctype html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <title>Străzi – OpenLayers</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@latest/ol.css">
  <style>
    html, body, #map { height: 100%; margin: 0; }

    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      background: rgba(255,255,255,0.92);
      padding: 10px;
      border-radius: 10px;
      box-shadow: 0 1px 8px rgba(0,0,0,0.18);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: 14px;
      min-width: 300px;
      max-width: 360px;
    }

    #controls label {
      display: block;
      margin-bottom: 6px;
      font-weight: 700;
    }

    select {
      width: 100%;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,0.15);
      background: white;
      font-size: 14px;
    }

    #basemapSelect { margin-bottom: 10px; }
    #attributeSelect { margin-bottom: 10px; }

    #hint {
      margin-top: 8px;
      font-size: 12px;
      opacity: 0.75;
    }

    /* Legend */
    #legendTitle { font-weight: 800; margin: 8px 0 6px; }
    .legendItem { display: flex; gap: 8px; align-items: flex-start; margin: 6px 0; }
    .swatch { width: 14px; height: 14px; border-radius: 4px; margin-top: 2px; border: 1px solid rgba(0,0,0,0.15); flex: 0 0 14px; }
    .legendText { line-height: 1.25; }
    .legendCode { font-weight: 800; margin-right: 6px; }
    .legendDesc { opacity: 0.92; }
    .legendNote { font-size: 12px; opacity: 0.75; margin-top: 6px; }
  </style>
</head>
<body>
  <div id="controls">
    <label for="basemapSelect">Basemap</label>
    <select id="basemapSelect">
      <option value="carto_light" selected>CARTO Positron (light)</option>
      <option value="carto_dark">CARTO Dark Matter</option>
      <option value="osm">OpenStreetMap (color)</option>
    </select>

    <label for="attributeSelect">Color by</label>
    <select id="attributeSelect"></select>

    <div id="legend"></div>

    <div id="hint">Tip: hover peste stradă pentru detalii.</div>
  </div>

  <div id="map"></div>

  <script src="https://cdn.jsdelivr.net/npm/ol@latest/dist/ol.js"></script>
  <script>
    // ---- Config: keep ONLY these attributes in the dropdown ----
    // NOTE: keys must match your GeoJSON property names EXACTLY.
    // The code also normalizes diacritics for the legend description mapping.
    const ALLOWED_ATTRIBUTES = [
      'STANDARD CARTIER',
      'DISTANȚA FAȚĂ DE CENTRU',
      'TIP CAROSABIL',
      'GRAD DE DOTARE',
      'CARACTERISTICI GEO',
      'RESTRICTII PUG',
      'GRAD DE POLUARE',
      'ZONĂ FISCALĂ'
    ];

    // Preferred default if present
    const PREFERRED_DEFAULTS = [
      'ZONĂ FISCALĂ',
      'STANDARD CARTIER',
      'DISTANȚA FAȚĂ DE CENTRU',
      'TIP CAROSABIL',
      'GRAD DE DOTARE',
      'CARACTERISTICI GEO',
      'RESTRICTII PUG',
      'GRAD DE POLUARE'
    ];

    // Selected attribute (will be set after data loads)
    let selectedAttribute = 'ZONĂ FISCALĂ';

    // Prefer these fields for "street name" in tooltip (fallback chain)
    const NAME_FIELDS = ['STRADA', 'DENUMIRE', 'Nume', 'name', 'Name'];

    // A/B/C/D palette
    const gradeColors = {
      'A': '#1a9641',
      'B': '#a6d96a',
      'C': '#fdae61',
      'D': '#d7191c',
      'C/D': '#f46d43'
    };

    // ---- Criterion descriptions (legend text) ----
    const CRITERIA_INFO = {
      'STANDARD CARTIER': {
        title: 'C1 – Standardul de zonă',
        grades: {
          'A': 'zona centrului istoric, centrală, de maximă atractivitate',
          'B': 'zona mediană, de atractivitate medie',
          'C': 'zona de atractivitate redusă',
          'D': 'zona neatractivă sau în extinderea intravilanului'
        }
      },
      'DISTANȚA FAȚĂ DE CENTRU': {
        title: 'C2 – Distanța față de centrul municipiului',
        grades: {
          'A': 'zona centrală',
          'B': 'zona mediană',
          'C': 'zona marginală',
          'D': 'zona periferică și în extinderea intravilanului'
        }
      },
      'TIP CAROSABIL': {
        title: 'C3 – Tipul drumului de acces la teren',
        grades: {
          'A': 'stradă modernizată',
          'B': 'stradă asfaltată',
          'C': 'stradă pietruită',
          'D': 'drum balastat sau de câmp'
        }
      },
      'GRAD DE DOTARE': {
        title: 'C4 – Gradul de echipare cu utilități a zonei',
        grades: {
          'A': 'echipare cu toate rețelele și transport în comun',
          'B': 'echipare cu toate rețelele și la distanță mică față de linia de transport în comun',
          'C': 'echipare cu toate rețelele și la distanță medie față de linia de transport în comun',
          'D': 'echipare cu rețele edilitare, fără canalizare / departe de linia de transport în comun (sau echipare redusă)'
        }
      },
      'CARACTERISTICI GEO': {
        title: 'C5 – Caracteristicile geotehnice ale zonei',
        grades: {
          'A': 'terenuri normale bune de fundare',
          'D': 'terenuri dificile (alunecări, torenți, pante accentuate, zone mlaștinoase), neapte pentru construcții sau care necesită măsuri speciale de fundare'
        }
      },
      'RESTRICTII PUG': {
        title: 'C6 – Restricții impuse de PUG',
        grades: {
          'A': 'pentru funcțiuni comerciale',
          'D': 'pentru funcțiuni incompatibile'
        }
      },
      'GRAD DE POLUARE': {
        title: 'C7 – Gradul de poluare cu reziduuri și noxe a zonei',
        grades: {
          'A': 'fără poluare',
          'B': 'nivel mediu (praf, gaze de eșapament)',
          'C': 'poluare industrială accentuată',
          'D': 'poluare fonică accentuată (zonă afectată de aeroport)'
        }
      },
      'ZONĂ FISCALĂ': {
        title: 'Zonă fiscală',
        grades: {
          'A': 'zonă A',
          'B': 'zonă B',
          'C': 'zonă C',
          'D': 'zonă D'
        }
      }
    };

    function normKey(s) {
      return String(s ?? '')
        .trim()
        .toUpperCase()
        .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // remove diacritics
        .replace(/\s+/g, ' ');
    }

    // Normalized criteria mapping
    const CRITERIA_INFO_NORM = {};
    for (const [k, v] of Object.entries(CRITERIA_INFO)) {
      CRITERIA_INFO_NORM[normKey(k)] = v;
    }

    // Cache styles for performance
    const styleCache = new Map();
    function styleForColor(color) {
      if (!styleCache.has(color)) {
        styleCache.set(color, new ol.style.Style({
          stroke: new ol.style.Stroke({ color, width: 3 })
        }));
      }
      return styleCache.get(color);
    }

    // Stable color from any value (categorical): hash -> HSL
    function colorFromValue(v) {
      const s = String(v ?? '—');
      let hash = 0;
      for (let i = 0; i < s.length; i++) hash = (hash * 31 + s.charCodeAt(i)) >>> 0;
      const hue = hash % 360;
      return `hsl(${hue} 65% 45%)`;
    }

    function styleFeature(feature) {
      const v = feature.get(selectedAttribute);
      const color = (v in gradeColors) ? gradeColors[v] : colorFromValue(v);
      return styleForColor(color);
    }

    // Vector layer
    const streetsLayer = new ol.layer.Vector({
      source: new ol.source.Vector({
        url: './strazi_impozite.geojson',
        format: new ol.format.GeoJSON()
      }),
      style: styleFeature
    });

    // Basemaps (Option 1 grayscale + OSM color)
    const basemaps = {
      carto_light: new ol.layer.Tile({
        visible: true,
        source: new ol.source.XYZ({
          url: 'https://{a-d}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
          attributions: '© OpenStreetMap contributors © CARTO'
        })
      }),
      carto_dark: new ol.layer.Tile({
        visible: false,
        source: new ol.source.XYZ({
          url: 'https://{a-d}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
          attributions: '© OpenStreetMap contributors © CARTO'
        })
      }),
      osm: new ol.layer.Tile({
        visible: false,
        source: new ol.source.OSM()
      })
    };

    const map = new ol.Map({
      target: 'map',
      layers: [
        basemaps.carto_light,
        basemaps.carto_dark,
        basemaps.osm,
        streetsLayer
      ],
      view: new ol.View({
        center: ol.proj.fromLonLat([23.6, 46.77]),
        zoom: 12
      })
    });

    // ---- Tooltip on hover ----
    const tooltip = document.createElement('div');
    tooltip.style.position = 'absolute';
    tooltip.style.background = 'rgba(255,255,255,0.95)';
    tooltip.style.padding = '6px 8px';
    tooltip.style.borderRadius = '10px';
    tooltip.style.boxShadow = '0 1px 10px rgba(0,0,0,0.2)';
    tooltip.style.fontFamily = 'system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';
    tooltip.style.fontSize = '13px';
    tooltip.style.pointerEvents = 'none';
    tooltip.style.transform = 'translate(10px, 10px)';
    tooltip.style.display = 'none';
    document.body.appendChild(tooltip);

    function getStreetName(feature) {
      for (const k of NAME_FIELDS) {
        const val = feature.get(k);
        if (val !== undefined && val !== null && String(val).trim() !== '') return String(val);
      }
      return '(fără nume)';
    }

    map.on('pointermove', (evt) => {
      const feature = map.forEachFeatureAtPixel(evt.pixel, f => f);
      if (!feature) {
        tooltip.style.display = 'none';
        return;
      }

      const streetName = getStreetName(feature);
      const v = feature.get(selectedAttribute);

      tooltip.innerHTML = `
        <div><b>${streetName}</b></div>
        <div>${selectedAttribute}: <b>${(v ?? '—')}</b></div>
      `;
      tooltip.style.left = `${evt.originalEvent.pageX}px`;
      tooltip.style.top  = `${evt.originalEvent.pageY}px`;
      tooltip.style.display = 'block';
    });

    // ---- Basemap selector wiring ----
    document.getElementById('basemapSelect').addEventListener('change', (e) => {
      const chosen = e.target.value;
      for (const [key, layer] of Object.entries(basemaps)) {
        layer.setVisible(key === chosen);
      }
    });

    // ---- Legend ----
    const legendEl = document.getElementById('legend');

    function updateLegend() {
      if (!legendEl) return;
      if (!selectedAttribute) {
        legendEl.innerHTML = '';
        return;
      }

      const info = CRITERIA_INFO_NORM[normKey(selectedAttribute)];
      const features = streetsLayer.getSource().getFeatures();

      // unique values in data for selected attribute
      const values = new Set();
      for (const f of features) {
        const v = f.get(selectedAttribute);
        if (v !== undefined && v !== null && String(v).trim() !== '') values.add(String(v));
      }

      const order = ['A','B','C','D'];
      const hasABCD = order.some(g => values.has(g));

      let html = '';
      html += `<div id="legendTitle">${info?.title ?? selectedAttribute}</div>`;

      if (info?.grades) {
        const gradesToShow = Object.keys(info.grades);
        for (const g of gradesToShow) {
          if (hasABCD && !values.has(g)) continue;
          const color = gradeColors[g] || colorFromValue(g);
          html += `
            <div class="legendItem">
              <div class="swatch" style="background:${color};"></div>
              <div class="legendText">
                <span class="legendCode">${g}</span>
                <span class="legendDesc">${info.grades[g]}</span>
              </div>
            </div>
          `;
        }
        html += `<div class="legendNote">Legendă pentru criteriul selectat (conform baremurilor).</div>`;
      } else {
        const sorted = Array.from(values).sort((a,b) => a.localeCompare(b, 'ro')).slice(0, 12);
        for (const v of sorted) {
          const color = (v in gradeColors) ? gradeColors[v] : colorFromValue(v);
          html += `
            <div class="legendItem">
              <div class="swatch" style="background:${color};"></div>
              <div class="legendText">${v}</div>
            </div>
          `;
        }
        if (values.size > 12) html += `<div class="legendNote">+ încă ${values.size - 12} valori…</div>`;
      }

      legendEl.innerHTML = html;
    }

    // ---- Attribute selector: ONLY allowed list, but skip ones not present in data ----
    const selectEl = document.getElementById('attributeSelect');

    streetsLayer.getSource().on('change', () => {
      if (streetsLayer.getSource().getState() !== 'ready') return;

      // Fit to data
      const extent = streetsLayer.getSource().getExtent();
      if (extent && extent.every(Number.isFinite)) {
        map.getView().fit(extent, { padding: [30,30,30,30] });
      }

      // Populate dropdown once
      if (selectEl.options.length > 0) return;

      const first = streetsLayer.getSource().getFeatures()[0];
      if (!first) return;

      const props = first.getProperties();

      // filter by exact property match
      const available = ALLOWED_ATTRIBUTES.filter(k => Object.prototype.hasOwnProperty.call(props, k));

      // If none match exactly (likely diacritics differences), show allowed list anyway
      const keysToShow = available.length ? available : ALLOWED_ATTRIBUTES;

      for (const k of keysToShow) {
        const opt = document.createElement('option');
        opt.value = k;
        opt.textContent = k;
        selectEl.appendChild(opt);
      }

      // Choose default from preferred list
      selectedAttribute = PREFERRED_DEFAULTS.find(p => keysToShow.includes(p)) ?? keysToShow[0] ?? null;

      if (selectedAttribute) {
        selectEl.value = selectedAttribute;
        streetsLayer.changed();
        updateLegend();
      }
    });

    selectEl.addEventListener('change', (e) => {
      selectedAttribute = e.target.value;
      streetsLayer.changed();
      updateLegend();
    });
  </script>
</body>
</html>
